!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ArgElement	include/argparse.h	/^typedef struct ArgElement {$/;"	s
ArgElement	include/argparse.h	/^}ArgElement;$/;"	t	typeref:struct:ArgElement
ArgList	include/argparse.h	/^typedef struct ArgList{$/;"	s
ArgList	include/argparse.h	/^}ArgList;$/;"	t	typeref:struct:ArgList
ArgList_free	include/argparse.h	/^int ArgList_free(ArgList* list);$/;"	p	signature:(ArgList* list)
ArgList_make	include/argparse.h	/^ArgList* ArgList_make(int argc, char** argv);$/;"	p	signature:(int argc, char** argv)
ArgList_make	src/argparse.c	/^ArgList *ArgList_make(int argc, char** argv){$/;"	f	signature:(int argc, char** argv)
Argument	include/argparse.h	/^typedef struct Argument {$/;"	s
Argument	include/argparse.h	/^}Argument;$/;"	t	typeref:struct:Argument
BINDIR	Makefile	/^BINDIR=bin$/;"	m
BINNAME	Makefile	/^BINNAME=todoc$/;"	m
CC	Makefile	/^CC=gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS= -Wall -I$(INCLUDE) -g $/;"	m
CONFIG_H	include/config.h	2;"	d
DYNLIB	Makefile	/^DYNLIB=$(BINNAME).dll$/;"	m
EXECUTABLE	Makefile	/^EXECUTABLE=$(BINNAME)$/;"	m
INCLUDE	Makefile	/^INCLUDE=include$/;"	m
LDFLAGS	Makefile	/^LDFLAGS= -static -L. -ltodoc$/;"	m
LFLAGS	Makefile	/^LFLAGS= -shared -Wl,-soname,$(SONAME)$/;"	m
LIBNAME	Makefile	/^LIBNAME=lib$(BINNAME)$/;"	m
LIBOBJS	Makefile	/^LIBOBJS:=$(filter-out obj\/todo.o,$(OBJS))$/;"	m
List	include/list.h	/^typedef struct llist List;$/;"	t	typeref:struct:llist
ListNode	include/list.h	/^}ListNode;$/;"	t	typeref:struct:listelem
List_add	include/list.h	/^int List_add(List* list, void* thingy);$/;"	p	signature:(List* list, void* thingy)
List_add	src/list.c	/^int List_add(List* l, void* item){$/;"	f	signature:(List* l, void* item)
List_do	include/list.h	/^int List_do(List* list, void (*function)(void*));$/;"	p	signature:(List* list, void (*function)(void*))
List_do	src/list.c	/^int List_do(List* list, void (*function)(void*)){$/;"	f	signature:(List* list, void (*function)(void*))
List_filter	include/list.h	/^List* List_filter(List* list, bool (*function)(void*));$/;"	p	signature:(List* list, bool (*function)(void*))
List_filter	src/list.c	/^List* List_filter(List* list, bool (*fun)(void*)){$/;"	f	signature:(List* list, bool (*fun)(void*))
List_free	include/list.h	/^int List_free(List* this);$/;"	p	signature:(List* this)
List_free	src/list.c	/^int List_free(List* list)$/;"	f	signature:(List* list)
List_get	include/list.h	/^void* List_get(List* list, int index);$/;"	p	signature:(List* list, int index)
List_get	src/list.c	/^void* List_get(List* l, int index){$/;"	f	signature:(List* l, int index)
List_map	include/list.h	/^List* List_map(List* list, void* (*function)(void*));$/;"	p	signature:(List* list, void* (*function)(void*))
List_map	src/list.c	/^List* List_map(List* list, void* (*function)(void*)){$/;"	f	signature:(List* list, void* (*function)(void*))
List_new	include/list.h	/^List* List_new();$/;"	p	signature:()
List_new	src/list.c	/^List* List_new(){$/;"	f
List_pop	include/list.h	/^void* List_pop(List* list);$/;"	p	signature:(List* list)
List_remove	include/list.h	/^void* List_remove(List* list, int index);$/;"	p	signature:(List* list, int index)
List_remove	src/list.c	/^void* List_remove(List* l, int index){$/;"	f	signature:(List* l, int index)
MODULES	Makefile	/^MODULES=$/;"	m
OBJDIR	Makefile	/^OBJDIR=obj$/;"	m
OBJECT	Makefile	/^OBJECT=$(SRCS:.c=.o)$/;"	m
OBJS	Makefile	/^OBJS:=$(patsubst $(SRCDIR)\/%,$(OBJDIR)\/%,$(OBJECT))$/;"	m
PKGNAME	Makefile	/^PKGNAME=$(BINNAME)-$(VERSION)$/;"	m
SONAME	Makefile	/^SONAME=$(LIBNAME).so.$(VERSION)$/;"	m
SOURCE	Makefile	/^SOURCE=*.c$/;"	m
SRCDIR	Makefile	/^SRCDIR=src$/;"	m
SRCS	Makefile	/^SRCS:=$(wildcard $(SRCDIR)\/$(SOURCE))$/;"	m
STATLIB	Makefile	/^STATLIB=$(LIBNAME).a$/;"	m
TASK	include/task.h	8;"	d
TASKLIST	include/tasklist.h	2;"	d
TASK_SORT	include/task_sort.h	2;"	d
TESTDIR	Makefile	/^TESTDIR=test$/;"	m
TESTFLAGS	Makefile	/^TESTFLAGS=$/;"	m
TESTPRG	Makefile	/^TESTPRG=$(BINNAME)_test$/;"	m
TESTSRC	Makefile	/^TESTSRC:=$(wildcard $(TESTDIR)\/$(SOURCE))$/;"	m
Task	include/task.h	/^}Task;$/;"	t	typeref:struct:task_t
Tasklist	include/tasklist.h	/^}Tasklist;$/;"	t	typeref:struct:tasklist_t
VERSION	Makefile	/^VERSION=0.2.5$/;"	m
_LLIST	include/list.h	5;"	d
__ARGPARSE__	include/argparse.h	4;"	d
__SPEEDUNIT	test/speedunit.h	15;"	d
__dbg_h__	include/dbg.h	4;"	d
add_get_test	test/list_test.c	/^void add_get_test(){$/;"	f
add_task	src/todoc.c	/^int add_task(char* filename, char* string){$/;"	f	signature:(char* filename, char* string)
alphaSort	include/task_sort.h	/^int alphaSort(char* a, char* b);$/;"	p	signature:(char* a, char* b)
append_test	test/task_test.c	/^void append_test(){$/;"	f
applytestfn	test/list_test.c	/^void applytestfn(void* v){$/;"	f	signature:(void* v)
arg	include/argparse.h	/^    Argument *arg;$/;"	m	struct:ArgElement	access:public
arglist_add	src/argparse.c	/^int arglist_add(ArgList* l, Argument* a){$/;"	f	signature:(ArgList* l, Argument* a)
argparse_fixture	test/argparse_test.c	/^void argparse_fixture(){$/;"	f
check	include/dbg.h	29;"	d
check_debug	include/dbg.h	38;"	d
check_mem	include/dbg.h	35;"	d
clean_errno	include/dbg.h	19;"	d
complete	include/task.h	/^    bool complete;    $/;"	m	struct:task_t	access:public
complete_task	src/todoc.c	/^void complete_task(char* filename, int number)$/;"	f	signature:(char* filename, int number)
complete_test	test/task_test.c	/^void complete_test(){$/;"	f
data	include/list.h	/^    void* data;$/;"	m	struct:listelem	access:public
debug	include/dbg.h	13;"	d
debug	include/dbg.h	15;"	d
description	include/task.h	/^	char* description;$/;"	m	struct:task_t	access:public
destroy_element	src/list.c	/^int destroy_element(ListNode* target){$/;"	f	signature:(ListNode* target)
destroytask	src/tasklist.c	/^void destroytask(void* item){$/;"	f	signature:(void* item)
do_test	test/list_test.c	/^void do_test(void){$/;"	f	signature:(void)
dump_test	test/task_test.c	/^void dump_test(){$/;"	f
first	test/list_test.c	/^char* first = "one";$/;"	v
free_argelems	src/argparse.c	/^void free_argelems(ArgElement *element){$/;"	f	signature:(ArgElement *element)
free_arglist	src/argparse.c	/^void free_arglist(ArgList *list){$/;"	f	signature:(ArgList *list)
free_argument	src/argparse.c	/^void free_argument(Argument *arg){$/;"	f	signature:(Argument *arg)
get_priority	src/task.c	/^char get_priority(Task* task){$/;"	f	signature:(Task* task)
head	include/argparse.h	/^    struct ArgElement *head;$/;"	m	struct:ArgList	typeref:struct:ArgList::ArgElement	access:public
head	include/list.h	/^    ListNode* head;$/;"	m	struct:llist	access:public
keyword_test	test/task_test.c	/^void keyword_test(){$/;"	f
length	include/argparse.h	/^    int length;$/;"	m	struct:ArgList	access:public
length	include/list.h	/^    int length;$/;"	m	struct:llist	access:public
linkedlist_fixture	test/list_test.c	/^void linkedlist_fixture()$/;"	f
list	include/tasklist.h	/^    List* list;$/;"	m	struct:tasklist_t	access:public
list_alloc_test	test/list_test.c	/^void list_alloc_test(){$/;"	f
list_free_test	test/list_test.c	/^void list_free_test(){$/;"	f
list_tasks	src/todoc.c	/^int list_tasks(char* filename){$/;"	f	signature:(char* filename)
list_tasks_matching	src/todoc.c	/^void list_tasks_matching(char* filename, char* string){$/;"	f	signature:(char* filename, char* string)
listelem	include/list.h	/^typedef struct listelem{$/;"	s
llist	include/list.h	/^struct llist {$/;"	s
load_configuration	include/config.h	/^void load_configuration();$/;"	p	signature:()
load_configuration	src/config.c	/^void load_configuration(){$/;"	f
log_err	include/dbg.h	22;"	d
log_info	include/dbg.h	26;"	d
log_warn	include/dbg.h	24;"	d
main	src/todoc.c	/^int main(int argc, char* argv[]){$/;"	f	signature:(int argc, char* argv[])
main	test/todo_test.c	/^int main(int argc, char** argv){$/;"	f	signature:(int argc, char** argv)
make_single_item_list	test/tasklist_test.c	/^Tasklist* make_single_item_list(){$/;"	f
make_three_item_list	test/tasklist_test.c	/^Tasklist* make_three_item_list(){$/;"	f
name	include/argparse.h	/^    char *name;$/;"	m	struct:Argument	access:public
new_argelem	src/argparse.c	/^ArgElement* new_argelem(Argument* arg){$/;"	f	signature:(Argument* arg)
new_argument	src/argparse.c	/^Argument* new_argument(){$/;"	f
next	include/argparse.h	/^    struct ArgElement *next;$/;"	m	struct:ArgElement	typeref:struct:ArgElement::ArgElement	access:public
next	include/list.h	/^    struct listelem* next;$/;"	m	struct:listelem	typeref:struct:listelem::listelem	access:public
no_args	test/argparse_test.c	/^void no_args(){$/;"	f
option	include/argparse.h	/^    char *option;$/;"	m	struct:Argument	access:public
parse_test	test/task_test.c	/^void parse_test(){$/;"	f
prev	include/list.h	/^    struct listelem* prev;$/;"	m	struct:listelem	typeref:struct:listelem::listelem	access:public
print_help	src/todoc.c	/^void print_help(){$/;"	f
print_short_help	src/todoc.c	/^void print_short_help(){ $/;"	f
print_version	src/todoc.c	/^void print_version(){$/;"	f
priority	include/task.h	/^	char priority;$/;"	m	struct:task_t	access:public
prioritySort	include/task_sort.h	/^int prioritySort(char* a, char* b);$/;"	p	signature:(char* a, char* b)
remove_task	src/todoc.c	/^int remove_task(char* filename, int number){$/;"	f	signature:(char* filename, int number)
remove_test	test/list_test.c	/^void remove_test(void){$/;"	f	signature:(void)
second	test/list_test.c	/^char* second = "two";$/;"	v
sentinel	include/dbg.h	32;"	d
slide	src/list.c	/^ListNode* slide(ListNode* sl, int howmuch){$/;"	f	signature:(ListNode* sl, int howmuch)
sp_assert	test/speedunit.h	26;"	d
sp_pfail	test/speedunit.h	24;"	d
sp_run_suite	test/speedunit.h	35;"	d
sp_run_test	test/speedunit.h	32;"	d
sp_streql	test/speedunit.h	28;"	d
sp_suite_start	test/speedunit.h	30;"	d
strings_equal	src/todoc.c	/^bool strings_equal(char* subject, char* first, char* sec){$/;"	f	signature:(char* subject, char* first, char* sec)
tail	include/list.h	/^    ListNode* tail;$/;"	m	struct:llist	access:public
task_append	include/task.h	/^int task_append(Task* t, char* string);$/;"	p	signature:(Task* t, char* string)
task_append	src/task.c	/^int task_append(Task* t, char* string){$/;"	f	signature:(Task* t, char* string)
task_complete	include/task.h	/^void task_complete(Task* task);$/;"	p	signature:(Task* task)
task_complete	src/task.c	/^void task_complete(Task* task){$/;"	f	signature:(Task* task)
task_dump	include/task.h	/^char* task_dump(Task* t);$/;"	p	signature:(Task* t)
task_dump	src/task.c	/^char* task_dump(Task* t){$/;"	f	signature:(Task* t)
task_fixture	test/task_test.c	/^void task_fixture(){$/;"	f
task_free	include/task.h	/^void task_free(Task* task);$/;"	p	signature:(Task* task)
task_free	src/task.c	/^void task_free(Task* task){$/;"	f	signature:(Task* task)
task_has_context	include/task.h	/^int task_has_context(Task* t, char* context);$/;"	p	signature:(Task* t, char* context)
task_has_keyword	include/task.h	/^bool task_has_keyword(Task* t, char* string);$/;"	p	signature:(Task* t, char* string)
task_has_keyword	src/task.c	/^bool task_has_keyword(Task* t, char* keyword){$/;"	f	signature:(Task* t, char* keyword)
task_has_project	include/task.h	/^int task_has_project(Task* t, char* project);$/;"	p	signature:(Task* t, char* project)
task_new	include/task.h	/^Task* task_new();$/;"	p	signature:()
task_new	src/task.c	/^Task* task_new(){$/;"	f
task_parse	include/task.h	/^void task_parse(Task* t, char* string);$/;"	p	signature:(Task* t, char* string)
task_parse	src/task.c	/^void task_parse(Task* task, char* string){$/;"	f	signature:(Task* task, char* string)
task_print	include/task.h	/^void task_print(Task* t);$/;"	p	signature:(Task* t)
task_set_string	include/task.h	/^void task_set_string(Task* t, char* string);$/;"	p	signature:(Task* t, char* string)
task_set_string	src/task.c	/^void task_set_string(Task* t, char* string){$/;"	f	signature:(Task* t, char* string)
task_setup	test/task_test.c	/^void task_setup(){$/;"	f
task_t	include/task.h	/^typedef struct task_t{$/;"	s
tasklist_append	include/tasklist.h	/^int tasklist_append(Tasklist *list, Task *task);$/;"	p	signature:(Tasklist *list, Task *task)
tasklist_append	src/tasklist.c	/^int tasklist_append(Tasklist* this, Task* t){$/;"	f	signature:(Tasklist* this, Task* t)
tasklist_display	include/tasklist.h	/^int tasklist_display(Tasklist *list);$/;"	p	signature:(Tasklist *list)
tasklist_display	src/tasklist.c	/^int tasklist_display(Tasklist* list){$/;"	f	signature:(Tasklist* list)
tasklist_dump	include/tasklist.h	/^int tasklist_dump(Tasklist *list, FILE* file);$/;"	p	signature:(Tasklist *list, FILE* file)
tasklist_dump	src/tasklist.c	/^int tasklist_dump(Tasklist *list, FILE* f){$/;"	f	signature:(Tasklist *list, FILE* f)
tasklist_fixture	test/tasklist_test.c	/^void tasklist_fixture(){$/;"	f
tasklist_free	include/tasklist.h	/^void tasklist_free(Tasklist *list);$/;"	p	signature:(Tasklist *list)
tasklist_free	src/tasklist.c	/^void tasklist_free(Tasklist* list){$/;"	f	signature:(Tasklist* list)
tasklist_get	include/tasklist.h	/^Task* tasklist_get(Tasklist* list, int index);$/;"	p	signature:(Tasklist* list, int index)
tasklist_get	src/tasklist.c	/^Task* tasklist_get(Tasklist* list, int index){$/;"	f	signature:(Tasklist* list, int index)
tasklist_merge	include/tasklist.h	/^Tasklist* tasklist_merge(Tasklist *list, Tasklist *other);$/;"	p	signature:(Tasklist *list, Tasklist *other)
tasklist_new	include/tasklist.h	/^Tasklist* tasklist_new();$/;"	p	signature:()
tasklist_new	src/tasklist.c	/^Tasklist* tasklist_new(){$/;"	f
tasklist_read	include/tasklist.h	/^int tasklist_read(Tasklist *list, FILE* file);$/;"	p	signature:(Tasklist *list, FILE* file)
tasklist_read	src/tasklist.c	/^int tasklist_read(Tasklist *list, FILE* f){$/;"	f	signature:(Tasklist *list, FILE* f)
tasklist_remove	include/tasklist.h	/^Task* tasklist_remove(Tasklist* list, int index);$/;"	p	signature:(Tasklist* list, int index)
tasklist_remove	src/tasklist.c	/^Task* tasklist_remove(Tasklist* list, int index){$/;"	f	signature:(Tasklist* list, int index)
tasklist_search	include/tasklist.h	/^Tasklist* tasklist_search(Tasklist *list, char *string);$/;"	p	signature:(Tasklist *list, char *string)
tasklist_search	src/tasklist.c	/^Tasklist* tasklist_search(Tasklist* list, char* filter){$/;"	f	signature:(Tasklist* list, char* filter)
tasklist_t	include/tasklist.h	/^typedef struct tasklist_t {$/;"	s
testarray	test/list_test.c	/^char* testarray[] = {"two", "one", "three"};$/;"	v
tests_failed	test/speedunit.h	/^int tests_failed;$/;"	v
tests_run	test/speedunit.h	/^int tests_run;$/;"	v
third	test/list_test.c	/^char* third = "three";$/;"	v
tlist_append_test	test/tasklist_test.c	/^void tlist_append_test(){$/;"	f
tlist_get_test	test/tasklist_test.c	/^void tlist_get_test(){$/;"	f
tlist_load_test	test/tasklist_test.c	/^void tlist_load_test(){$/;"	f
tlist_remove_test	test/tasklist_test.c	/^void tlist_remove_test(){$/;"	f
tlist_search_test	test/tasklist_test.c	/^void tlist_search_test(){$/;"	f
